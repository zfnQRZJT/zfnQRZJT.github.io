<!doctype html>
<html>
  <head>
    <title>Region simulator</title>
    <script>
      const find = function(elem) {return(document.getElementById(elem));}
      var N; var ctx; var pointlocs; var lines; var intlocs = [];
      const regenerate = function() {
        N = find("howmanypoints").value;
        ctx = find("cv").getContext('2d');
        pointlocs = [];
        lines = []; intlocs = [];
        for (let i = 0; i < N; i++) {
          let x = 600*Math.random() - 300; let y;
          if (find("convex").checked) {
            y = Math.sqrt(300*300 - x*x)*(2*Math.floor(2*Math.random()) - 1);
          } else {
            y = 600*Math.random() - 300;
          }
          let newpo = [x + Math.random()*10 + 400,y + Math.random()*10 + 400,pointlocs.length - 1,0];
          newpo.push(newpo[0],newpo[1],0);
          pointlocs.push(newpo);
        }
        //now we have a bunch of points and have to connect them
        lines = [];
        for (let i = 0; i < N; i++) {
          let currarr = [];
          for (let j = 0; j < i; j++) {
            let thissplit = [[],[]];
            let p1 = pointlocs[i]; let p2 = pointlocs[j]; let sl = (p2[1] - p1[1])/(p2[0] - p1[0]);
            for (let k = 0; k < N; k++) {
              if (k !== i && k !== j) {
                if (pointlocs[k][0]*sl + p1[1] - sl*p1[0] < pointlocs[k][1]) {
                  thissplit[0].push(k);
                } else {
                  thissplit[1].push(k);
                }
              }
            }
            currarr.push([sl,p1[1] - sl*p1[0],thissplit]);
          }
          lines.push(JSON.parse(JSON.stringify(currarr)));
        }
        console.log(JSON.stringify(lines));
        console.log(pointlocs);
        //return;
        //now we have to find all those line intersections yayyyyy
        for (let i = 1; i < N; i++) {
          for (let j = 0; j < i; j++) {
            let thesplit = lines[i][j][2];
            lines[i][j].push([pointlocs[i],pointlocs[j]]);
            for (let K = 0; K < thesplit[0].length; K++) {
              for (let L = 0; L < thesplit[1].length; L++) {
                let k = thesplit[0][K]; let l = thesplit[1][L];
                let secline = lines[Math.max(k,l)][Math.min(k,l)];
                if (!(secline)) {console.log(i,j,k,l);}
                let intpointx = (secline[1]-lines[i][j][1])/(lines[i][j][0]-secline[0]);
                if (Math.min(pointlocs[i][0],pointlocs[j][0]) < intpointx && intpointx < Math.max(pointlocs[i][0],pointlocs[j][0])) {
                  //real intersection
                  let realinter = [i,j,Math.max(k,l),Math.min(k,l),intpointx,lines[i][j][0]*intpointx + lines[i][j][1]];
                  lines[i][j][3].push(realinter);
                  if (i > Math.max(k,l)) {
                    intlocs.push(realinter);
                  }
                }
              }
            }
            lines[i][j][3].sort((a,b) => a[4] - b[4]);
          }
        }
        ctx.reset();
        ctx.font = "15px serif";
        for (let i = 0; i < pointlocs.length; i++) {
          ctx.fillStyle="black";
          for (let j = 0; j < i; j++) {
            ctx.moveTo(pointlocs[i][0],pointlocs[i][1]);
            ctx.lineTo(pointlocs[j][0],pointlocs[j][1]);
          }
          drawp(pointlocs[i],i);
        }
        ctx.stroke();
        for (let i = 0; i < intlocs.length; i++) {
          drawp(intlocs[i],i);
        }
      }
      const drawp = function(p,ind) {
        ctx.fillStyle = "black";
        ctx.fillRect(p[4] - 5,p[5] - 5,10,10);
        ctx.fillStyle="gray";
        ctx.fillText(ind,p[4],p[5]);
      }
      const isvert = function(p) {
        for (let findp = 0; findp < pointlocs.length; findp++) {
          if (Math.abs(pointlocs[findp][0] - p[0]) < 0.00001 && Math.abs(pointlocs[findp][1] - p[1]) < 0.00001) {
            return(pointlocs);
          }
        }
        return(false);
      }
      /*const findline = function(p) {
        if (isvert(p)) {throw Error("tried to find the line of a vertex " + p); return;}
        for (let findp = 0; findp < intlocs.length; findp++) {
          if (Math.abs(intlocs[findp][4] - p[0]) < 0.00001 && Math.abs(intlocs[findp][5] - p[1]) < 0.00001) {
            return([intlocs[findp]]);
          }
        }
      }*/
      const findindonlin = function(po,li) {
        for (let fpi = 0; fpi < li[3].length; fpi++) {
          if (Math.abs(li[3][fpi][4] - po[4]) + Math.abs(li[3][fpi][5] - po[5]) < 0.000001) {
            return(fpi);
          }
        }
        return(-1);
      }
      const traceReg = function(p1,p2) {
        let regbord = [p1,p2];
        let currlin;
        let currdir = Math.sign(p2[4] - p1[4]);
        if (p1.length === 7) {
          //p1 is a vertex
          if ([p2[0],p2[1]].includes(p1[2])) {
            currlin = [p2[0],p2[1]];
          } else {
            currlin = [p2[2],p2[3]];
          }
        } else {
          if ((p1[0] === p2[0] && p1[1] === p2[1]) || (p1[0] === p2[2] && p1[1] === p2[3])) {
            currlin = [p1[0],p1[1]];
          } else {
            currlin = [p1[2],p1[3]];
          }
        }
        while (regbord[regbord.length - 1] !== regbord[0]) {
          let nowpoint = regbord[regbord.length - 1];
          let newlin;
          if (nowpoint.length === 7) {
            throw Error("vertex found" + nowpoint);
            return;
          }
          if (regbord.length >= 4*N) {
            console.log(regbord);
            throw Error("region too many sides");
            return;
          }
          //we have the current line, find the next line
          if (nowpoint[0] === currlin[0]) {
            newlin = [nowpoint[2],nowpoint[3]];
          } else {
            newlin = [nowpoint[0],nowpoint[1]];
          }
          console.log(newlin,currlin,regbord);
          newlin = lines[newlin[0]][newlin[1]];
          if (newlin[0] < lines[currlin[0]][currlin[1]][0]) {
            //we just decreased our slope.
            currdir *= -1;
          }
          let newnewpoint = newlin[findindonlin(nowpoint,newlin) + currdir];
          regbord.push(newnewpoint);
          currlin = newlin;
        }
        return(regbord);
      }
      //window.onload = regenerate;
    </script>
  </head>
  <body>
    <input id="howmanypoints" type="range" min="3" max="15" value="6"><br>
    <input id="convex" type="checkbox"><label for="convex">Convex or not</label><br>
    <button id="regen" onclick="regenerate()">Regenerate</button><br>
    <canvas id="cv" width="800" height="800"></canvas>
  </body>
</html>
